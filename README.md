搞清楚网络!!!

# 协议和层

TCP/IP协议是一个分层联网协议。它包含IP和位于其上的其他协议层。

TCP/IP协议具有一个重要原则——**封装**。其关键概念为：低层不会对高层传来的信息进行解释。

当信息从高层传向低层，会加一层本层的头信息。而信息从低层传向高层时，会有一个解包的过程。

一个应用A向应用B传输信息的大致过程
```
             封装为 包      封装为 帧               检查 IP 头部 若匹配，剥离 IP 头部，将段交给传输层。
             添加 IP 头部   添加 帧头和帧尾          若不匹配且本机为路由器，则重新路由转发
             |             |                     |
应用A->传输层->网络层->数据链路层->网络介质->数据链路层->网络层->传输层->应用B(接收数据)
       |                       |       |                |
       添加 传输层头部           比特流   剥离帧头和帧尾      检查端口号，确定目标应用    
       封装为 段 或 数据报。              校验帧完整性       剥离传输层头部，将原始数据交给应用层。
高层                        低层      低层                        高层
```

IP是一种`无连接`和`不可靠`的协议。它不保证包到达的顺序和发送的顺序一致。也不保证不会重复发送和到达接收者。网络的可靠性由如TCP一样的可靠传输层协议维护。

TCP传输的每一个字节都有一个顺序号(ISN)来表明这个字节的位置。如果接收者发现数据顺序不正确，接收方会通过一些机制来告知发送者重新发送。TCP通过`滑动窗口`控制流量。

# TCP三次握手四次挥手

为了连接可靠，TCP通过三次握手建立连接，四次挥手终止连接。

三次握手会确定ISN初始序列号，并准备好传输数据。

## 三次握手

*第一次握手*:
SYN 即 Synchronize(同步) 是TCP协议中的一种控制位。客户端会向服务器发送一个有SYN标志的数据包，以发起建立连接的请求。并且客户端会选择一个随机序列号(x)作为初始序列号，发送给服务器。客户端的TCP状态变为`SYN_SENT`

*第二次握手*:
服务器接收带有SYN标志位的数据包后，会回复一个带有SYN和ACK标志的数据包。ACK即Acknowledgement，确认应答。并且服务器也会生成并返回一个初始序列号(y)。然后服务器会响应一个确认号(x+1)。服务器的TCP状态变为` SYN_RECEIVED`

*第三次握手*:
客户端接收到SYN-ACK数据包后，发送一个ACK标志数据包(SYN=0,ACK=1)给服务器，确认接收到服务器的SYN包，并发送一个确认号(y+1)。

此时，服务器和客户端的TCP状态都变为`ESTABLISHED`，连接建立。

## 四次挥手

*第一次挥手*:
主动关闭方发送带FIN(finish)标志包，序列号为x，表示没有数据要发送了。发送的一方进入`FIN_WAIT_1`状态。

*第二次挥手*:
收到FIN请求后，被动者回复一个ACK包，确认受到FIN请求，确认号为x+1。被动关闭方进入`CLOSE_WAIT`状态。
主动关闭方收到ACK后进入`FIN_WAIT_2`状态

*第三次挥手*:
被动关闭方完成数据发送，发送带FIN标志位包，序列号为y，进入`LAST_ACK`状态。

*第四次挥手*:
主动关闭方收到FIN,发送带ACK标志位包，(确认号y+1)，进入`TIME_WAIT`状态
被动关闭方收到ACK后关闭连接，主动关闭方等待 2*MSL（最长报文段寿命）后关闭连接(要确保被动方接收到ACK)。

# 大小端序转换函数

定义在<arpa/inet.h>中的四个函数 

`uint16_t htons(uint16_t host_uint16_t);`

将16位无符号短整数从主机字节序转换为网络字节序。(通常转换端口号)

`uint32_t htonl(uint32_t host_uint32_t);`

将32位无符号长整数从主机字节序转换位网络字节序。(通常转换IP地址)

`uint16_t ntohs(uint16_t net_uint16_t);` 和 `uint32_t ntohl(uint32_t net_uint32_t);` 